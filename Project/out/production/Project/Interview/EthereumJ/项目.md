## 概述

基于netty通信框架、redis做数据缓存、springboot实现前后端请求及管理、
nginx实现反向代理和负载均衡。实现一个跨链资产兑换信息匹配平台。

由多个注册中心（对外暴露一个**nginx**端口），能提供跨链转移的服务商（在两条链上都拥有资产货币）
通过**netty**注册到注册中心，注册中心临时存储记录（**redis**）。为了保持及时性和可用性，
需要通过**心跳**包来维持连接，在短时间内断线之后还可以重连。当一段时间没有重连后，删除掉**过期key**。
触发**事件通知**（修改redis配置）注册中心，注册中心一并**删除**（过期删除，可能不完全）相关信息。
注册中心也会主动检测key有无过期。

有跨链需求的用户通过注册中心的web界面，可以根据自己的需求量来匹配到一个可以提供服务的服务商。
注册中心将客户信息发给服务商，然后通过设置和执行智能合约，来实现原子（由机制和理性人分析保证）的哈希锁定跨链协议。

## version 1.0.0

### 流程分析

区块链A中 某个账户发起转账请求，向智能合约输入区块链B中B的收款地址，并且向智能合约账户中转入金额。

智能合约收到跨链请求，向平台发送信息，平台指定到具体的一个跨链账户，将hash条件和收款地址以及合约地址转发给这个账户。
账户将指定的金额和解锁条件转给区块链B的智能合约，当B上某账户提供了这个合约的解锁条件，就可以获得这笔金额，
同时智能合约将解锁条件发送给中间账户，中间账户用同样的方式获得A中的金额。

### 需求分析

（假设跨链请求已经发给平台） 平台选择一个余额（需验证）大于请求金额的账户来处理本次跨链交易。
平台给该账户发送消息（两个智能合约地址、两个账户地址、转账金、交易比例）账户收到消息后返回收到，并修改自己的余额。

### 详细设计

**通信框架**：netty

第一次客户端（中间账户）给服务端提交注册，（注册信息），之后每隔一定时间进行心跳续约（心跳消息）
，服务端收到消息之后更新相关key的过期时间。客户端下线时发送注销（注销请求），服务器端清理掉。

**解决方案**：

1. **注册及续约**：redis中无法针对hash的某个field键值对过期的设计。
因此设计三个数据结构：1. hash：field是独一无二的键（uuid），value是客户端的ip+port+账户。
2. zset：存uuid和账户提供的余额。 3. string：uuid：uuid，这里的string设置为经过多久自动过期。
过期之后触发事件返回给服务端，服务端再删除其余两个数据结构中对应的uuid的内容。

**注**：这里的uuid可以是对账户B链地址的hash+salt，防止重复注册，这个hash应该只能由服务端生成。

2. **处理跨链请求**：服务器端选一个余额大于跨链请求的客户端，有两种通知客户端的办法：
(1）调用智能合约发送消息 （2）服务端与客户端新建一个socket连接，两者的角色互换，有服务端主动给客户端发消息

3. **服务注销**：客户端开两个线程

#### 1. 注册中心

数据持久化：redis+lettuce

可视化界面及容器：springboot

通信框架：netty

编写步骤：

先实现与数据库的交互

#### 2. 客户端

#### 3. 转发端

受智能合约调用，智能合约中有跨链请求后，将信息传递给转发端

选中的转账账户，通过redis查询到客户端和注册中心的绑定关系（长连接），通知给某个具体的注册中心，该注册中心再通知给客户端。
客户端再去处理相关逻辑。



