## JVM内存模型

### java 虚拟机栈

**栈帧**：支持虚拟机方法调用和方法执行的数据结构，是虚拟机栈的栈元素。

栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。在编译程序代码的时候，栈帧中需要多大的局部变量表内存，多深的操作数栈都已经完全确定了。

局部变量表：基本数据类型的局部变量，方法内部的对象引用和返回地址。

操作数栈：通过出栈进栈来计算数据。

动态链接：包含指向运行时常量池中栈帧所属方法的引用，用于运行时动态转化为直接引用。

方法出口：方法返回指令 ： 执行引擎遇到一个方法返回的字节码指令，这时候有可能会有返回值传递给上层的方法调用者，这种退出方式称为正常完成出口。异常退出 ： 在方法执行过程中遇到了异常，并且没有处理这个异常，就会导致方法退出。

### OOM

#### 1. OutOfMemoryError

##### 1.1 java heap space

堆（heap）是jvm存放对象实例的内存区域，有两种情况会导致OOM：

1. 内存泄漏：在对象不再被程序使用以后，仍然被不正确的引用导致无法被回收而占用内存，直到没有内存可用。

   可以通过引用链来分析泄露的原因，使用Jprofiler，visualvm工具。

2. 内存溢出：新建对象实例大于堆的可用空间。

   可以通过增大堆的内存来解决。

##### 1.2 PermGen space

持久代可以分为方法区和方法区中的常量池。

1. 当加载的类过多或者是有多余的class没有卸载掉占用空间，就会抛出OOM
2. 常量池需要的空间大于常量池实际空间是也会抛出OOM。

##### 1.3 java stack space(unable to create new native thread )

虚拟机为每个线程都分配独立的栈空间，当虚拟机可以分配的栈空间小于线程需要的空间时，就会抛出OOM。单线程下由于栈帧过大或者是虚拟机栈容量太小，都是报StackOverflow。

**一个线程拥有一个私有虚拟机栈；**

**一个虚拟机栈可以拥有多个栈帧；**

**一个栈帧对应一个方法的调用；**

#### 2. StackOverflowError（stack space）

方法运行的时候，请求新建栈帧时，栈所剩空间小于栈帧所需空间。出现这种异常最常见的就是递归调用层次太多，导致栈不能创建新的栈帧

#### 3. 虚拟机各种内存参数



#### 4. java8中的内存模型变化

取消了永久代，将方法区的数据存到了metaspace中，导致永久代不再和堆相连，无法使用堆的GC，而是存在本地内存。这里不会触发GC。字符串等常量池移入堆中。



## GC 垃圾回收

### 概述

垃圾收集器只关注堆和方法区中的内存如何回收，因为虚拟机栈、本地方法栈、程序计数器都是伴随着线程的生命周期，线程结束，这部分内存也就自然被回收；堆和方法区是线程共享的。堆中主要存放的就是对象，回收的第一件事就是先判断对象是否存活。对象回收需要两次标记。

### GC 触发条件

1. 程序中调用```System.gc()```
2. 系统自己决定触发时机

### 对象存活判断方法

#### 1. 引用计数法（不使用）

给对象添加一个引用计数器，每有一个地方引用它时就+1，当引用失效或者引用它的对象被回收-1。计数器为0时，对象就认为是已经不存活。

优点：实现简单

缺点：无法解决循环引用，即两个对象相互引用，你中有我我中有你。

#### 2. 可达性分析法

从GC root 对象作为起点，向下搜索，搜索走过的路径称为引用链。那些不在引用链上的对象就是不可用的。

在Java中，可以作为GC Roots 的对象包括：

* 虚拟机栈中的引用的对象
* 方法区中静态变量引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI引用的对象
* 所有线程对象
* **所有跨代引用对象；**
* **和已知 GCRoots 对象同属一个CardTable 的其他对象。**

young GC时，不需要扫描所有是GCRoot的老年代的引用，只需要扫描dirty card中dirty的那一部分。

优点：解决了循环引用的问题。

缺点：需要的时间多，分析过程需要停顿所有java执行线程（stop the world）

**三色标记法**

黑色：该对象的引用的所有对象都被加入了接下来访问的集合中

灰色：该对象的引用的所有对象没有全部被加入了接下来访问的集合中

白色：没有访问到的对象

可能的问题，多标：把本来已经不存活的对象认为存活。漏标：将一个已经认为不存活的对象又指向黑色的对象，该对象复活，但是会被GC回收。

**card table**：jvm将堆空间划分为512字节的卡页（card），再创建卡表数组，每一个数组元素代表卡页的状态。当一个对象的引用关系改变时，写屏障逻辑将会标记对象所在的卡页为dirty card。然后在最终标记阶段重新扫描dirty card，完善存活对象。card table中的元素也可以表示哪一个页中的对象引用了新生代对象。从而减少扫描数量。CMS关心新引用的建立，G1关心旧引用的删除。dirty card也可以用于**跨代标记**。不用扫描所有的root对象，只扫描dirty card中的老年代对象。

增量更新-CMS：当一个黑色对象引用了一个白色对象，记录这个黑色对象，在重新标记阶段重新扫描。

SATB-G1：记录一个快照，当灰色对象删除了白色对象的引用。把白色对象推到GC栈中，根据rset能找到是否被黑色对象引用，再决定删不删。使用写屏障记录引用的改变。

#### finalize() 方法

当对象经过可达性分析之后发现不在引用链上，先判断对象有没有必要执行finalize()方法。如果对象没有覆盖finalize()方法或者finalize()方法已经被执行过，那么该对象可以被直接回收。如果需要则执行finalize()方法，判断执行后是否会在引用链上，如果回到引用链上则不用清除。

不建议使用finalize()自救对象，因为执行的时间不确定且运行代价高。

### 回收方法区

永久代的垃圾收集主要分为两部分内容：**废弃常量**和**无用的类**。

#### 1. 废弃常量

没有任何引用指向的常量

#### 2. 无用的类

需要同时满足下面三个条件：

1. 该类所有的实例都已经被回收，也就是Java堆中无任何该类的实例。
2. 加载该类的ClassLoader已经被回收。
3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

### 安全点和安全区域

JVM不是在任何情况下都能进行GC，因此引入安全点来保证GC之后程序依然可以正常运行。GC的目的是帮助我们回收不再使用的内存，在多线程环境下这种回收将会变得非常复杂，要安全地回收需要满足一下两个条件：

1.堆内存的变化是受控制的，最好所有的线程全部停止。

2.堆中的对象是已知的，不存在不再使用的对象很难找到或者找不到，即堆中的对象状态都是可知的。

**安全点**：Java线程执行到某个位置这时候JVM能够安全、可控的回收对象，这样就不会导致回收正在使用的对象。

安全点主要在以下位置设置：

1. 循环的末尾

2. 方法返回前

3. 调用方法的call之后

4. 抛出异常的位置

**安全区域**：为了防止线程长时间到达不了安全点，而使用安全区域。安全区域是指一段代码片中，引用关系不会发生变化，在这个区域任何地方GC都是安全的，是安全点的一个扩展。当线程执行到安全区域时，GC可以不用管安全区域的线程，当线程执行完安全区域后，要等GC Roots枚举结束，否则线程继续等待。

### 垃圾回收算法

#### 1. 标记-清除

经过判断认为需要回收的对象，会被标记，然后直接回收。

优点：简单基础

缺点：会有内存碎片，浪费空间

#### 2. 复制算法

将内存分为大小相同的两部分，每次只使用其中一部分。当需要回收时，将没有标记的存活对象复制到另一部分，再把已经使用的内存空间清空。

优点：实现简单

缺点：浪费一半空间，代价大，而且对象存活时间越长，每次复制就越浪费时间

##### 2.1 HotSpot虚拟机的改良算法

1. 弱代理论：许多对象存活时间很短，而且很少有对象从老年的变成年轻代，GC年龄最大值为15，因为对象头中只有四位表示年龄，最大是15。

2. 改良算法和堆内存布局：

   回收时将Eden+survivor空间中的存活的对象移动到另一个survivor中。如果另一个survivor不够容纳存活的对象，那么这些对象将通过**分配担保**机制直接进入老年代。

   新生代区包含：1个Eden + 2个survivor，默认比例是8：1

#### 3. 标记-整理算法

在标记清除的基础上，让存活的对象都向一个方向移动，然后清理掉边界以外的内存。

优点：存活对象多时不像复制算法一样浪费时间，也不会产生内存碎片

缺点：添加了整理过程，效率比较低

#### 4. 分代算法

新生代中使用复制算法，因为大部分对象存活时间短；老年代适用标记-清除或者标记-整理算法。

### 垃圾收集器

![img](../picture/jvm垃圾收集器.png)

如果两个收集器之间存在连线，则说明它们可以搭配使用。虚拟机所处的区域则表示它是属于新生代还是老年代收集器。

**新生代收集器**：Serial、ParNew、Parallel Scavenge

**老年代收集器**：CMS（并发标记清除）、Serial Old、Parallel Old

**整堆收集器**： G1

**并行收集**：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。

**并发收集**：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个CPU上。

**吞吐量**：即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )）。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%

#### 1. Serial 收集器

回收算法：复制

单线程，简单高效，单CPU下没有切换线程的开销，收集垃圾时需要暂停其他所有的工作线程（stop the world）

#### 2. ParNew 收集器

回收算法：复制

除了使用多线程外其余行为均和Serial收集器一模一样（参数控制、收集算法、Stop The World、对象分配规则、回收策略等）。

#### 3. Parallel Scavenge 收集器

回收算法：复制

属于新生代收集器也是采用**复制**算法的收集器，又是并行的多线程收集器（与ParNew收集器类似）。

**GC自适应调节策略**：动态调节虚拟机参数，使得吞吐量最高，

#### 4. Serial Old 收集器

回收算法：标记-整理

Server模式下主要的两大用途：

1. 在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用。
2. 作为CMS收集器的后备方案，在并发收集Concurent Mode Failure时使用。

#### 5. **Parallel Old 收集器**

是Parallel Scavenge收集器的老年代版本。

**特点**：多线程，采用标记-整理算法。

**应用场景**：注重高吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old 收集器。

#### 6. CMS 收集器

一种以获取最短回收停顿时间为目标的收集器。

**收集时机**：设置为老年代内存占用达到某个阈值开始回收。

**特点**：基于**标记-清除**算法实现。并发收集、低停顿。可以设置在n次标记清除之后使用标记整理。只回收老年代。 

**CMS收集器的运行过程分为下列4步：**

初始标记：标记一下GC Roots能直接关联到的老年代对象，时间很短但是会STW

并发标记：GC Roots的Trancing，同时用户线程也在进行，时间最久

重新标记：修正并发标记期间用户程序运行导致标记变动的对象的标记，会STW

并发清除：清除线程和用户线程一起工作

**缺点**：会有内存碎片，内存碎片会提前导致对象无法分配内存，从而导致**Concurrent Mode Failure**。**出现此现象的原因主要有两个：一个是在年老代被用完之前不能完成对无引用对象的回收，新的大对象移入老年代时没有空间，当新空间分配请求在年老代的剩余空间中得不到满足。另一个是老年代剩余空间小于survivor+from。**出现这种情况就会使CMS转向serialOld收集。**晋升失败**：判断担保空间足够，但是因为内存碎片无法分配，这种情况下直接fullgc



#### 7.G1收集器

用分区的概念将堆分为若干个区域region，每个内存区域可能是新生代也可能是老年代，不再是固定的。用户线程和GC线程独立的使用每个分区，减少了同步时间。每个分区中又划分了许多卡片，对象以卡片为单位分配内存。

并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间。部分收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让Java程序继续运行。

分代收集：G1能够独自管理整个Java堆，并且采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。

空间整合：G1运作期间不会产生空间碎片，收集后能提供规整的可用内存。整体上像**标记整理**，在两个region之间是**复制**。

可预测的停顿：G1除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。

**已记忆集合 Remember Set (RSet)**

G1为了避免STW式的整堆扫描，在每个分区记录了一个已记忆集合(RSet)，内部类似一个反向指针，记录引用分区内对象的卡片索引。当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区内的对象存活情况。

**Collection Set**

一些region的集合，g1只关注这些region的引用。

**初始标记**：仅标记GC Roots能直接到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象。（需要线程停顿，但耗时很短。）

**并发标记**：从GC Roots开始对堆中对象进行可达性分析，找出存活对象。（耗时较长，但可与用户程序并发执行）

**最终标记**：为了修正在并发标记期间因用户程序执行而导致标记产生变化的那一部分标记记录。且对象的变化记录在线程Remembered Set Logs里面，把Remembered Set Logs里面的数据合并到Remembered Set中。（需要线程停顿，但可并行执行。）

**筛选回收**：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。（可并发执行）

### Minor GC

触发条件：当Eden区满时，触发Minor GC。

前三种垃圾收集器都是执行Minor GC，而且都会STW。

### Full GC

触发条件：

1. 调用System.gc()时，系统建议执行Full GC，但是不必然执行。
2. 老年代空间不足
3. 方法区空间不足
4. 通过多次Minor GC后凭借存活时间正常进入老年代的大小大于老年代的可用内存
5. 分配担保时老年代内存不够新进入的对象

避免频繁full GC：

1. 尽量不要在代码中调用，让虚拟机自己去管理它的内存，可通过通过**-XX:+ DisableExplicitGC**禁止RMI调用System.gc()。
2. 尽量让新生代对象在新生代区多经过几次minor GC，避免大对象和大数组的创建
3. 如果是CMS中出现promotion failed和concurrent mode failure，则会导致full GC。开启CMS的标记整理