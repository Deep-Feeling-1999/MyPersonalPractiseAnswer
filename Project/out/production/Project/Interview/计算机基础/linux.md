fork函数

fork函数通过系统调用创建一个与原来进程几乎完全相同的进程，然后两个进程接下来执行相同的代码。一个进程调用fork函数后，系统先给新的进程分配资源，把父进程的所有值复制给新进程。

返回值

fork函数会返回两个值，对子进程来说，fork返回0，对父进程来说，fork返回子进程pid，如果创建失败，返回负值。创建失败的原因可能是：

1. 系统进程数已经达到系统规定的上限，返回值为eagain
2. 系统内存不足，返回值为enomem

pipe函数

pipe函数用于创建一个管道，实现**父子**进程间通信，```int pipe(int fd[2]);```参数是一对打开的文件描述符。只能往fd[1]写，从fd[0]读。要实现双向通信，需要两个管道。从空的管道内read会被阻塞，向满的管道内write也会被阻塞。

如果fd[1]的引用计数减少为0，则没有任何进程需要写数据，对fd[0]的read操作将返回0，即EOF。反之如果fd[0]的引用计数减少为0，写端文件描述符fd[1]的write操作会失败，引发SIGPIPE信号。

管道内部数据是字节流，默认大小为65536

## 进程

### 孤儿进程

父进程退出，但是子进程还在运行，子进程会被init进程（pid为1）的进程收养，并且被init进程完成状态收集工作。

### 僵尸进程

子进程退出后，父进程没有通过wait或waitpid获取子进程的状态信息，那么子进程的描述符还保留在系统中，称为僵尸进程，通过ps命令显示状态为Z。

**危害**：如果父进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。

**清除方法**：

1. 改写父进程，子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。
2. 杀掉父进程，僵尸进程变为孤儿进程。

**避免方法**：

1. fork两次，fork的子进程只是为了创建孙进程，然后子进程先退出，父进程的wait方法就可以返回，孙子进程可以异步执行，同时孙子进程就变成了僵尸进程。 

## shell

shell就是用户和内核的桥梁，用户输入命令，shell解析成内核可以理解的指令，然后调用内核处理。

### 后台运行

在运行命令的末尾加 & 可以使进程后台执行，但是shell关闭后进程也就停止了。在命令前加 nohup 即使shell关闭，进程依然运行。

# 命令

ls：展示文件夹内容

cd：目录切换

cp：复制文件

rm：删除文件

mv：移动文件

pwd：打印当前工作目录

tar：解压

mkdir：创建目录

ps：展示进程状态

kill：杀死进程

top：展示进程资源占用情况

chmod：改变文件权限

vim/vi：打开vim编辑文件

cat：查看文件内容

tail：从指定点开始查看文件内容

# 文件系统

### inode

文件索引节点，存储文件元信息，包含文件字节数、UID、gid、访问权限、时间戳、链接数、块数、块位置（inode号码）、块大小。但不包含文件名。

操作系统将硬盘分为两个区域，一个是数据区存放文件，另一个是inode table。用inode号码标识不同的文件，文件名是inode号码的别称。通过文件名打开文件，先找到文件名对应的inode编号，再通过inode找到block读取。

### 硬链接、软链接

使用```ln 源文件 目标文件```创建硬链接，这样可以使用不同的文件名访问同样的内容，删除一个文件名不影响其他文件名的访问。对文件内容的修改会影响到所有文件名。inode会记录硬链接数，增加1，删除一个文件名，链接数减1。直到值减到0，删除inode节点。

软链接中两个文件的inode不一样，但是文件A的内容是文件B的路径。读取A时系统就会导向B。文件B被删除后，打开A就会报错。而且inode链接数不会变化。