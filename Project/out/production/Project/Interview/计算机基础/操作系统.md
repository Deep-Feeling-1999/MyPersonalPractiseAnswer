# 进程

进程是资源分配的基本单位。进程包含程序、数据和PCB。

进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

进程内必须有至少一个线程，同时进程切换的开销比较大。

**进程上下文**

通俗讲就是进程在用户态运行时的环境以及自己的状态。

* 用户地址空间：代码段、数据段、用户堆栈
* 控制信息：程序控制块、内核栈
* 硬件上下文

## 组成

代码段

数据段：全局变量、常量、静态常量

堆栈段：函数的参数、函数的局部变量、进程控制块PCB（处于进程核心堆栈的底部）

### 进程控制块PCB

pcb是进程存在的唯一标识，系统通过pcb感知进程的存在。

系统通过pcb对进程进行调度和管理，包括创建进程、执行进程、退出进程以及改变进程优先级等

进程与pid是一对一，与程序是多对一。

包括：

1. 进程标识信息：pid， ppid
2. 处理器信息：程序计数器、栈指针等寄存器
3. 进程控制信息：调度和状态信息、进程间通信信息、存储管理信息、pcb链接信息

组织方式：相同状态的pcb可以顺序表或者链表形式组织。

### 程序转化为进程

1. 内核将程序代码和数据读入内存，为程序分配内存空间
2. 为进程分配进程标识符pid和其他资源
3. 内核为进程保存pid以及相关的信息，把进程放到运行队列等待执行

### 进程退出

正常退出：

* 调用exit()等待io缓存清理完才退出
* 调用_exit()直接退出
* main函数return

异常退出：

* 调用abort
* 由信号终止

退出后系统关闭进程打开的文件描述符，释放占用的内存资源。

问题：到底占用了哪些资源？

## 进程调度

**为什么要有进程调度**

进程执行需要处理器和内存资源，如果没有操作系统调度，由处理器自己选择进程来执行，可能出现不想要的结果，比如某个进程执行时间过长，其他进程等待太久而无法做到实时性。使用操作系统中合理的调度策略，就能实现想要的结果。

### 切换过程

切换的资源：虚拟空间目录、内核栈和硬件上下文

正在运行的进程A，发生中断，保存A的上下文到自己的内核栈，同时加载中断程序上下文，处理中断。由于进程不共享地址空间，还要切换地址空间，处理完后根据调度算法选择一个进程，加载该进程的上下文，切换页表，TLB失效，然后从内核栈中弹出上下文信息，继续运行。

### 1.  批处理系统

这类系统中没有太多用户操作，调度目标是保证吞吐量和周转时间

* 先来先服务FCFS（作业）
* 短作业优先SJF（作业）
* 最短剩余时间优先SRTN（抢占式）
* 响应比优先调度（作业）

### 2. 交互式系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

* 时间片轮转
* 优先级调度（作业）
* 多级反馈队列：多个队列，每个队列等待时间和执行时间依次增大，当时间片内一个进程没有执行完成，将进程放入下一级队列中。

## 进程间同步

### 1. 信号量

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

- **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
- **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

### 2. 管程

通过一次只能允许一个进程进入管程，来实现对互斥资源的访问。同时为了防止死锁还要设置条件来使进程让出管程。进程满足条件变量要求，则可以执行；否则退出，排队。

### 3. 消息



## 进程间通信

### 1. PIPE

管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。

它具有以下限制：

- 只支持半双工通信（单向交替传输）；
- 只能在父子进程或者兄弟进程中使用。

### 2. FIFO

命名管道，去除了管道只能在父子进程中使用的限制。

### 3. 消息队列

- 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
- 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

### 4. 信号量

控制多个进程对共享资源的访问。利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。

### 5. 共享存储

适合多个进程通信，而且是最快的方式。但是要考虑加锁同步。

### 6. 信号驱动

进程A给进程B发送一个信号，内核接收到以后放在B的信号队列中，当B进入内核态时，就会检测相应的信号，然后处理信号。

什么时候处理信号？

1. 当系统调用执行完要进入用户空间时，处理信号
2. 系统唤醒进程时

信号的处理方式？

1. 忽略：有些信号无法忽略，如kill -9 （sigkill）和 sigstop
2. 捕获：实现信号处理函数，当有某个信号时就运行对应的函数
3. 默认处理

### 7. 套接字

可以允许运行在不同的物理机上的进程通信

# 线程

线程是cpu独立调度的基本单位。

一个进程中可以有多个线程，它们共享进程资源。

## 线程切换

不需要地址空间的切换，只需要切换内核栈和硬件上下文。

**开销**：保存和恢复上下文、调度器进行线程调度、高速缓存重新加载或flush

**优化**：锁竞争太多就会导致线程来回调度。应该减少竞争：尽量减少锁的持有时间，同步代码中只保留同步相关代码；或者减小锁粒度，使用读写锁；或者使用乐观锁。

## 多进程和多线程的取舍

**多进程**：

* 优点：每个进程互相独立，不影响主程序。不用太麻烦的同步控制。
* 缺点：通信麻烦，传输数据开销较大。

**多线程**：

* 优点：所有线程可以直接共享变量和内存，程序控制简单，通信简单，而且使用的资源较少。
* 缺点：线程共用地址空间，受限于进程的地址空间，不能使用更多内存。线程同步问题比较麻烦。线程崩溃可能影响系统稳定性。

## 线程崩溃是否影响进程

进程和进程之间通过保护模式隔离了地址空间，一个进程崩溃不会影响其他无关进程。

但是线程之间共享同一空间，虽然每个线程有独立的栈空间，但是也可以访问到其他线程栈空间，这样就可能影响到其他线程，针对这种情况为了保证不出其他问题就直接停止进程。

Java中线程抛出异常没有捕获会崩溃，但是不影响其他线程。也不影响进程。

# 内存管理

**为什么要分段和分页？** --为了更好地利用内存

没有分段和分页之前，要运行一个程序必须将程序运行所需要的资源全部加载到连续的内存空间中，而且都是直接操作实际地址空间，有可能操作错误，修改了其他进程的地址空间，同时不能保证每次分配给进程的都是同一块地址空间，所以每次操作的地址空间不确定。还会导致由于分配的问题，内存空间使用不当，产生浪费。

## 虚拟内存

进程运行时，需要加载到内存中，但是没有一段可用的连续空间给进程，就需要使用虚拟内存技术。它使得进程认为自己在内存中拥有一段连续的内存空间，实际上拥有的是离散的，甚至只是一部分的内存空间。**虚拟内存空间大小为：min(内存＋外存， 寻址能力)。**

另一个好处是进程只能控制自己的逻辑空间，无法定位到其他进程的物理空间，实现了内存分配的隔离。

### TLB

首先查看虚拟地址是否在TLB中命中，如果命中直接返回对应的物理地址。但是如果是不同的进程使用TLB，会导致歧义问题，即相同的虚拟地址映射多个物理地址。所以在切换进程的时候会flush TLB，使表中内容无效。之后为每个表记录增加了ASID（地址空间ID），用于标识不同的进程，解决了歧义问题。如果是映射内核空间的地址，由于所有进程共享的缘故，可以不用比较ASID，设置标志位记录是否在内核空间。

**flush 时机**：

1. ASID已满，用bitmap记录
2. 建立页表映射时

## 线性、逻辑、物理地址

**逻辑地址**：程序段内部的偏移量

**线性地址**：段基址+段内偏移，段基址不一定是一个具体的物理地址，可能是段选择符，在通过GDT找到真实的段基址（保护模式，可以验证有无操作内存地址的权限）。

**物理地址**：真实的物理空间

## 分页存储管理

将进程的逻辑地址空间分为固定大小的页，内存也分为同样大小的页。页在内存中是不连续的，但是对进程表现出来是连续的。通过页表来实现逻辑地址到物理地址的转化。没有外部碎片。

页表：页号-物理块号，再加偏移量。

### 页面置换算法

* LRU：最近最久未使用的页被置换出去
* FIFO：先进先出
* 时钟置换算法
* OPT：将来最远被使用的页被置换

## 分段存储管理

根据逻辑的程序段划分地址，每个段大小不一样，没有内存内部碎片。段是信息的逻辑单位,它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。

段表：段号-基址，再加偏移量就能找到物理地址。

**段页式**：先将逻辑地址空间分段，再把每个段分页，每段的页号都是从0开始。

段页表：段号-页号-块号，再加偏移量就能找到地址。

# 内核态、用户态

**内核空间**：32位操作系统中，高1G的进程空间就是内核空间，内核空间被所有进程共享。

**用户空间**：低3G的空间是进程空间，每个进程之间独立。

**内核态**：一段程序需要执行系统调用陷入内核代码中，就是进入了内核态。操作系统运行在内核态。

**用户态**：除了内核态以外的。用户程序运行在用户态。

**特权指令**：操作系统内核可以执行的指令，如**IO指令、置终端屏蔽指令、清内存、建存储保护、设置时钟指令**等。

**非特权指令**：所有程序都可以使用的指令。

**用户态进入内核态的原因**：

* 系统调用（陷入）
* 异常
* 外部设备的中断

**切换过程**

1. 从进程控制块中提取指向内核栈的指针信息
2. 使用指针找到内核栈，保存当前进程的各种信息以及下一条指令
3. 恢复中断程序的上下文，执行中断处理程序。

**判断进程处于内核态还是用户态**

CS寄存器的低两位决定了当前CPU的特权等级。

