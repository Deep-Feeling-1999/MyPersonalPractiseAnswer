# socket通信

**socket**（套接字）：用**一对**ip+端口号来表示一个具体的应用，是通信中端到端的抽象。TCP和UDP都有套接字。

### 通信过程

服务器先调用```socket()```创建套接字，通过```bind()```将套接字与一个具体的ip和port绑定，再调用```listen()```，将套接字转化为**监听套接字**，表示该套接字已经可以接受客户端的连接请求。

服务器通过```accept()```来接收客户端发来的建立连接请求，并且返回一个**已连接套接字**（源ip端口+目的ip端口），就是个描述符。客户端和服务端使用这个套接字通信。在后续使用已连接套接字通信的过程中，监听套接字依旧在被监听。

```send()```将数据从Appbuffer复制到sendbuffer，或者是从kernelbuffer复制到sendbuffer，```recv()```处理相反的逻辑。

## HTTP

### 请求方法

post和get方法的区别：

post方法不幂等，每次提交都会让服务器做事情，因此不可以：

* GET在浏览器回退时是无害的，而POST会再次提交请求。

* GET产生的URL地址可以被Bookmark，而POST不可以。

* GET请求会被浏览器主动cache，而POST不会，除非手动设置。
* GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

另外

* GET请求在URL中传送的参数是有长度限制的，收到浏览器制约，而POST请求体长度不受制约。

* GET参数通过URL传递，POST放在Request body中。

* post在一定情况下可能会发送两个http请求，第一部分先发送请求头，观察服务端能否接受；第二部分再发送请求体。当请求体较小时，也可能一起发送。由客户端浏览器决定。

### 响应码

* 100 continued
* 200 ok

* 301 永久重定向，请求应该发到新的地址

* 302 临时重定向，以后的请求都继续发送给原有的地址

### HTTP1.1

**缓存处理**：引入了更多字段来采取更灵活的缓存策略

**带宽优化**：支持断点续传以及只请求某一部分资源

**错误管理**：新增了24个错误响应码

**host头处理**：传递主机名可以解决虚拟多主机共享同一ip的问题

**长连接**：增加connection字段

### HTTP2

**二进制分帧**：使用二进制格式解析，比基于文本解析的http1.x更方便而且健壮。解析文本时不能预测要在内存中分配多大的空间，只有在读取到换行符时才能处理。

**多路复用**：使用一个连接来传输所有并行的请求和响应，一个连接对应多个request，对同一域名的请求不再有数量限制。把通信单位缩小成更小的帧，并行的传递给服务端，同时并行的得到响应。一个连接对应多个请求响应，一个请求响应流对应多个帧。

**首部压缩**：服务端和客户端缓存一个属性表，如果有某个属性变化，那么就只传递这个属性。并且使用高效的压缩算法。

**服务端推送**

### HTTPS

在http的基础上加了一个ssl安全套接字层，流程如下：

1. 客户端将自己的一些元信息和一个随机数发给服务器端
2. server将自己的元信息和另一个随机数以及自己的公钥和证书发送给client，证书是CA私钥签名的服务端公钥。
3. client用CA的公钥解密证书，验证公钥和证书内容是否一致，若一致，用公钥加密第三个随机数发送给server。
4. server和client都有三个随机数，用共同的算法生成对称密钥，之后用这个密钥通信。

如何保证CA的公钥是可信的？

1. 操作系统、浏览器在安装时内置可信CA列表。

# TCP/IP

## 数据链路层

**作用**：在物理层的基础上向网络层提供服务，将上层报文传递到相邻节点的网络层。包括差错校验、流量控制和逻辑链路建立、管理。以太网帧内容长度46-1500位，使用crc（循环冗余校验）。

**不可靠**：数据链路层只能保证对端发来的数据帧是否由于物理层的原因而导致数据的变化。但是不能对帧进行排序，也不能要求重传，传送的过程中丢失也无法感知。

**Mac地址**表示一个物理网卡设备的地址，长度为48位。

## 网络层

**作用**：定义了所有端的逻辑地址，通过路由寻址找到路径来完成端到端的传输。

### IP

### ARP

ARP 实现由 IP 地址得到 MAC 地址。

### ICMP

**ping**：检测两个ip之间的连通性，请求端发送echo请求，接收端回复echo回复。

**traceroute**：用于跟踪一个分组到从源到目的ip地址的路径。

### NAT地址转换

将内网ip：port，映射为网关ip：port，外网返回数据时，根据ip：port返回给网关，网关再通过映射找到内网ip：port。

## TCP

面向连接，提供可靠交付（超时重传），有流量控制、拥塞控制，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），只能一对一，全双工通信。

### 三次握手

![img](../picture/三次握手.png)

为什么进行三次握手？

**防止client旧的建立连接请求**被阻塞在链路中，之后突然传送给server，server建立连接但是实际上客户端并没有请求，**防止浪费资源**。同时还能**同步双方序列号**。

当client没有收到ack时，重发syn，总尝试时间75S。

当server没有收到ack时，重发syn+ack，默认发5次，这期间可能会出现client超时关闭返回RST给server。

### 四次挥手

![img](../picture/四次挥手.jpg)

**挥手过程如果不能正常完成会怎么样**？

client没收到ack，则一直重传直到上限。

client没收到fin+ack，根据设置的超时时间，超时后关闭。

如果server发送fin包时client已经关闭，则client返回RST包给server。

**time_wait阶段为什么要等待2MSL（最大报文段存活时间）**？

为了确保最后一条挥手消息能被server端收到（**保证连接正常关闭**），同时清除网络中所有的相关报文。**防止新的连接中出现旧的报文**。

**close_wait过多**？

对端主动关闭了socketfd，但是服务端没有关闭，就会卡在close_wait。

**time_wait过多**？

短连接服务端主动断开时，如果有大量的短连接同时断开，那么就会出现很多time_wait。解决方法：由客户端主动断开，将短连接更改为长连接，或者是复用连接端口号。

### 报文类型

RST：关闭异常连接、复位。发送RST包时，丢弃所有缓冲区的包，接收端也不用ack。

**什么时候发送RST报文**？

1. 目标主机没有监听对应端口，就返回RST
2. 由于超时导致对端已经关闭了连接，然后又收到了被关闭连接的报文，返回RST
3. 对端或网络中防火墙拦截
4. 接收缓存中的数据未完全被应用程序读取时，关闭socket通信，就会返回一个RST
5. 在握手阶段中收到不正确的ack或者报文，返回RST

**RST攻击**

伪装成客户端向服务端发送RST包或者SYN包。伪装条件：模拟客户端的ip：port，同时序号在滑动窗口之内。

### 流量控制

流量控制是作用于端到端，为了让接受方来得及接受，接收方可以控制发送方的发送窗口大小，从而影响发送方的发送速率。

### 拥塞控制

拥塞的发生是全局性的，为了缓解整个网络的压力。

**基于丢包的reno算法**：

慢开始：初始cwnd为1，cwnd每次发送上一次两倍的消息，直到达到ssthresh门限值，然后进入拥塞避免阶段。

拥塞避免：cwnd每次加一，慢慢增长，直到发生超时现象（丢包）。

快重传：当收到了对一个包的重复确认，通常为3，那么立即重传这个包。

快恢复：当某个报文一直没有收到时，每收到一个新的报文就会返回消息，提醒发送缺失的报文。发送端在计算新的cwnd = 旧的cwnd/2，同时判断接收端接收了n个丢失包之后的包，就会发送cwnd + n 个包，然后再将cwnd - n，进行拥塞避免。

**基于延时的Vegas算法**

基本思路：RTT（往返时延：报文传输-响应时间）越大，cwnd越小。

**基于链路容量的BBR**

报文总量超过（网络带宽*传输时延），则认为出现了拥塞。

测量网络带宽：应答数据/应答时间，取十次的最大值。

测量往返时延：当往返时延不再增大时，减少数据包的发送，使RTT变小。

1. 起步阶段：慢开始，一直到发送速率增长小于25%
2. 排空阶段：减半发送速率，让缓冲区的报文发送完
3. 稳健阶段：轮换测量最大带宽和最小时延，计算新的发送速率

### 超时重传

tcp为每一个发送的报文设定一个计时器，如果在RTO内没有收到ACK，就会超时重传。采用自适应算法更新RTO = RTT（往返时间加权平均值）+4*往返时间偏差加权平均值。

### SYN FLOOD

解决方案：

**syn cookie**：在服务器接收到第一个syn之后，不为半连接分配数据区，而是返回一个带cookie的（syn+ack），客户端在第三次握手会返回这个cookie，服务端验证成功分配数据区。

增大半连接队列或者丢弃最早的半连接。

## 应用层

### DNS

解析过程：

1. 先在本地浏览器和操作系统以及host文件中查找有没有缓存，没找到进行下一步
2. 请求本地域名服务器，如果有缓存则返回，没有继续
3. 迭代解析：本地先请求根DNS，根DNS根据一级域名返回一个一级DNS，本地DNS再去请求一级DNS，再返回二级DNS，直到返回解析的ip
4. 递归解析：本地请求根，根请求一级，一级请求二级。。。直到找到ip，返回一级，返回根，返回本地

# 场景题

扫码登录的流程

1. 用户请求网页，服务端随机生成一个**字符串（全局唯一ID）**存入redis中，并且和登录接口共同生成一个二维码返回给用户。
2. 用户使用登录后的APP扫描二维码，向服务器发送登录请求和**字符串**，服务端将用户的信息作为value存入redis中。
3. 前端不停的使用**字符串**询问服务器是否登陆成功，如果登录成功返回token给浏览器，刷新界面。如果超时则会使二维码失效。